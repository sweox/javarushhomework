http://coub.com/view/8y58q
http://coub.com/view/6h7dc
http://coub.com/view/aouex
http://coub.com/view/5v1l9
http://coub.com/view/1o6lq
http://coub.com/view/2o41q
http://coub.com/view/8q1r3

http://coub.com/4fa4d18fc2a43b45862e12b1a226b2cc#simples
https://www.youtube.com/watch?v=aMhHq1R-9Rs
https://www.youtube.com/watch?v=VLMX7m1vmCo
https://www.youtube.com/watch?v=Wga5A6R9BJg

OutOfMemoryError как джавист вы должны поставить больше памяти
StackOverFlowError - вы должны переписать алгоритм(ваш алгоритм допускает слишком
глубокое погружение в эксепшн)
ClassNotFound... - забыли положить какой-то Jar-ник
----
Принципв SOLID
Полиморфизм, инкапсуляция, наследование, абстакция
----------------
Entity       hash.equal.tostr
Value Object  hash.equal.tostr   Programming language
Maneger/Service
Base/Abstract/Sceleton
Containers(в Java Collection) hash.equal.tostr
---
история переписывания метода sort на habrahabr

                    LEVEL 15
    level15.lesson12.bonus01
    Почему-то мой метод не работал
=================================================================

                    LEVEL 16
https://habrahabr.ru/post/132374/     Маленькие хитрости Java. Часть 2
com.javarush.test.level16.lesson13.home03;
Потоки
    //count--;
    System.out.println(new GenerateThread());
    //count--;
    Почему-то count в первом случае нормально уменьшается, а во фтором случае count в два раза больше.
---------------------------------------------------------
    level16.lesson13.bonus02
    Хорошая задача про потоки. Внизу задачи много полезных коментариев.
==================================================================
                    LEVEL 17
                    http://www.javenue.info/post/87
    level17.lesson02.task02
Конфликта не возникает, т.к. никто не запрещает этим самым потоком иметь одновременный доступ к одной и той
же области памяти. На самом деле каждый поток работает со своей копией переменной, т.к. у каждого потока свой
стэк вызовов методов и свои локальные переменные. Так вот, изначально, элементы массива храняться в heap jvm,
т.к. массив это объект, а объекты хранятся в heap. Когда мы создаем поток( при многоядерном процессоре)
каждый поток выполняется на отдельном ядре, и вот поток идет в heap, читает в кэш своего ядра переменную,
что-то с ней там делает, и снова в heap возвращает новое значение переменной. Т.е. поток меняет переменную
не в том месте, где она лежит в памяти, а в своем кэше. А записывает уже на то место, где она храниться в
heap.Может получиться так, несколько ядер(читай потоков) одновременно захотят свое значение записать обратно
в heap jvm, ну так этот конфликт решает уже ОС. А значение останется то, которое вернулось последним.
Советую посмотреть видео Головоча, станет более менее понятно https://www.youtube.com/user/KharkovITCourses/playlists?view=50&flow=list&shelf_id=7.
Смотреть раздел Threads все лекции, т.к. там много полезной инфы, можно не именно этот набор.
---------------------------------------------------
    level17.lesson04.task01 если же следовать условиям задачи и сделать так, то тестирование не проходит:
-----------------------------------------------------
    level17.lesson04.task03
А зачем в классе листы объявлены как funal?
И почему мы в них можем что то добавлять, ведь final переменная это неизменяемая константа?

объявляя лист ты не инициализируешь его содержимое.

то есть я могу инициализоровать его значение всего один раз?

вообще ты задал хороший вопрос =))
public final List<String> fruits = new ArrayList<String>()
это означает, что сам объект fruits ты можешь изменять, как хочешь: добавлять, вычитать, удалять и т.д. НО назначить fruits ссылку на новый объект нельзя, т.е. код
fruits = new ArrayList<String>();
вызовет ошибку.
---------------------------------------------------------------
    level17.lesson04.task04
Реализация Singleton в JAVA http://habrahabr.ru/post/27108/
How do I use a synchronized block in a static method? http://www.avajava.com/tutorials/lessons/how-do-i-use-a-synchronized-block-in-a-static-method.html
http://info.javarush.ru/JavaRush_tasks_discussion/2013/08/31/level17-lesson04-task04.html

    level17.lesson04.task05
-----------------------------------------------
    level17.lesson06.task02
До конца не понятно как работает программа
Почитать про volatile Ключевое слово volatile в Java http://ru.stackoverflow.com/questions/1271/%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-volatile-%D0%B2-java
---------------------------------------------------------------
    level17.lesson10.home02
Дебильное условие, много осталось не понятного про алгоритм приоритета пляжа.
get-теры можно не синхронизировать.
name можно не использовать.
--------------------------------------
test.level17.lesson10.home09
Что такое транзакционность???
--------------------------------------------------------------------
    level18.lesson05.task02
https://habrahabr.ru/post/178405/    Правильно освобождаем ресурсы в Java
http://book.itep.ru/10/ascii.htm    Коды символов ASCII
---------------------------------------------------------------
    level18.lesson08.task01
=============================================
http://habrahabr.ru/post/164487/        Многопоточность в Java
=====================================================
    level18.lesson10.home06
\r = CR (Carriage Return) // Used as a new line character in Mac OS before X
\n = LF (Line Feed) // Used as a new line character in Unix/Mac OS X
\r\n = CR + LF // Used as a new line character in Windows
==============================================
    test.level18.lesson10.home10
так Iterator там будет в любом случае, но по новому синтаксису — неявный!
если же ты настаиваешь на явном итераторе, то предлагаю сравнить такие два варианта кода:

for (final Iterator<Map.Entry<Integer, Integer>> i = map.entrySet().iterator(); i.hasNext(); ) {
  final Map.Entry<Integer, Integer> entry = i.next();
  System.out.println("" + entry.getKey() + "=" + entry.getValue());
}
и
for (final Map.Entry<Integer, Integer> entry : map.entrySet()) {
  System.out.println("" + entry.getKey() + "=" + entry.getValue());
}

Dec 2013 лекция 20
Class IllegalMonitorStateException

Если я использую локальную переменную в анонимном классе, компилятор требует объявить их final.
1. final - подсказывает программисту писателю, что это значение мы не будем менять.
2. final поле надо обязательно инициализировать.

    this - это ссылка на тот экземпляр у которого вызвали метод
Но для вызова статического класса экземпляр не нужен.
В таком случае ссылка идет по такому объекту App00.class (это тоже ссылочный тип)

    Integer от int(классы обертки от примитивов) отличаются тем что у них на одно больше
значение, т.е.любой int и  null.(Кроме double - есть NaN, Inf....)

    В нутри synchronized метода одновременно может находится только один поток. Это не
совсем так. В тот момент когда вы вызываете wait вы формально с точки синтаксиса Java остаетесь в
строчке wait, но с точки зрения многопоточности вы покидаете метод (отпустили synchronized)
и др. поток может зайти в synchronized.
    В случае sleep поток сохраняет за собой монитор
    И wait и sleep вырубают поток, но:
    1.wait - отпустили synchronized.
    2.sleep - сохраниет за собой монитор (не выходит из synchronized)


    Если метод static то synchronized выполняется по объекту класса (напр. public class App01x)
    public class App01x {
        public synchronized static void hello (int id) {
            try {
                App01x.class.wait(3000);
            }
            catch (IOException ignore) { /*NOP*/ }
        }
    }

    Если я не использую не случайно, а действительн не хочу использовать исключение
в try - catch, я вместо e пишу ignore (я действительно не буду использовать это
исключение) и в теле catch - /*NOP*/(тут пустое тело, но я так и задумал).

    Многопоточность вытесняющая.

    Астрал 1ч
    ============================================
    Dec 2013 лекция 21.1

    1. У класса всегда есть как минимум один конструктор.
    2. Если нет конструктора, компилятор добавить по умолчанию.
    3. В рамках конструктора потомка вызывается конструктор предка (super())

    super() - конструктор предка (ссылка)
    super. - ссылка на предка, который внутри вас (вызов кокструктора)
    this() - ссылка на мой конструктор (ссылка)
    this. - ссылка на меня (вызов конструктора)

    Конструкторы полностью эквивалентны методам:
    - точно также объявляются;
    - у них может быть область видимости (private, protected и т.д.);
    - они могут кидать исключения trows;
    Единственное отличие:
    - они ничего не возвращают (нельзя ставить возвращаемый результат void, int, String и т.д.)
    (нельзя декларировать возвращаемый результат)
    - нельзя ставить return чего-то (int, String, null и т.д.);
    - просто return можно;

    У Object есть метод hashcod он всегда возвращает один и тот-же int






