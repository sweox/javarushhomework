                    LEVEL 16
com.javarush.test.level16.lesson13.home03;
Потоки
    //count--;
    System.out.println(new GenerateThread());
    //count--;
    Почему-то count в первом случае нормально уменьшается, а во фтором случае count в два раза больше.
==================================================================
http://habrahabr.ru/post/164487/        Многопоточность в Java
================================================
                    LEVEL 17
    level17.lesson02.task02
Конфликта не возникает, т.к. никто не запрещает этим самым потоком иметь одновременный доступ к одной и той
же области памяти. На самом деле каждый поток работает со своей копией переменной, т.к. у каждого потока свой
стэк вызовов методов и свои локальные переменные. Так вот, изначально, элементы массива храняться в heap jvm,
т.к. массив это объект, а объекты хранятся в heap. Когда мы создаем поток( при многоядерном процессоре)
каждый поток выполняется на отдельном ядре, и вот поток идет в heap, читает в кэш своего ядра переменную,
что-то с ней там делает, и снова в heap возвращает новое значение переменной. Т.е. поток меняет переменную
не в том месте, где она лежит в памяти, а в своем кэше. А записывает уже на то место, где она храниться в
heap.Может получиться так, несколько ядер(читай потоков) одновременно захотят свое значение записать обратно
в heap jvm, ну так этот конфликт решает уже ОС. А значение останется то, которое вернулось последним.
Советую посмотреть видео Головоча, станет более менее понятно https://www.youtube.com/user/KharkovITCourses/playlists?view=50&flow=list&shelf_id=7.
Смотреть раздел Threads все лекции, т.к. там много полезной инфы, можно не именно этот набор.
=====================================================
Class IllegalMonitorStateException

Если я использую локальную переменную в анонимном классе, компилятор требует объявить их final.
1. final - подсказывает программисту писателю, что это значение мы не будем менять.
2. final поле надо обязательно инициализировать.

    this - это ссылка на тот экземпляр у которого вызвали метод
Но для вызова статического класса экземпляр не нужен.
В таком случае ссылка идет по такому объекту App00.class (это тоже ссылочный тип)

    Integer от int(классы обертки от примитивов) отличаются тем что у них на одно больше
значение, т.е.любой int и  null.(Кроме double - есть NaN, Inf....)

    В нутри synchronized метода одновременно может находится только один поток. Это не
совсем так. В тот момент когда вы вызываете wait вы формально с точки синтаксиса Java остаетесь в
строчке wait, но с точки зрения многопоточности вы покидаете метод (отпустили synchronized)
и др. поток может зайти в synchronized.
    В случае sleep поток сохраняет за собой монитор
    И wait и sleep вырубают поток, но:
    1.wait - отпустили synchronized.
    2.sleep - сохраниет за собой монитор (не выходит из synchronized)


    Если метод static то synchronized выполняется по объекту класса (напр. public class App01x)
    public class App01x {
        public synchronized static void hello (int id) {
            try {
                App01x.class.wait(3000);
            }
            catch (IOException ignore) { /*NOP*/ }
        }
    }

    Если я не использую не случайно, а действительн не хочу использовать исключение
в try - catch, я вместо e пишу ignore (я действительно не буду использовать это
исключение) и в теле catch - /*NOP*/(тут пустое тело, но я так и задумал).

    Многопоточность вытесняющая.

    Астрал 1ч









