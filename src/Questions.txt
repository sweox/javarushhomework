http://coub.com/view/8y58q
http://coub.com/view/6h7dc
http://coub.com/view/aouex
http://coub.com/view/5v1l9
http://coub.com/view/1o6lq
http://coub.com/view/2o41q
http://coub.com/view/8q1r3

http://coub.com/4fa4d18fc2a43b45862e12b1a226b2cc#simples
https://www.youtube.com/watch?v=aMhHq1R-9Rs
https://www.youtube.com/watch?v=VLMX7m1vmCo
https://www.youtube.com/watch?v=Wga5A6R9BJg

OutOfMemoryError как джавист вы должны поставить больше памяти
StackOverFlowError - вы должны переписать алгоритм(ваш алгоритм допускает слишком
глубокое погружение в эксепшн)
ClassNotFound... - забыли положить какой-то Jar-ник
----
Принципв SOLID
Полиморфизм, инкапсуляция, наследование, абстакция
----------------
Entity       hash.equal.tostr
Value Object  hash.equal.tostr   Programming language
Maneger/Service
Base/Abstract/Sceleton
Containers(в Java Collection) hash.equal.tostr
---
история переписывания метода sort на habrahabr

                    LEVEL 15
    level15.lesson12.bonus01
    Почему-то мой метод не работал
=================================================================

                    LEVEL 16
https://habrahabr.ru/post/132374/     Маленькие хитрости Java. Часть 2
com.javarush.test.level16.lesson13.home03;
Потоки
    //count--;
    System.out.println(new GenerateThread());
    //count--;
    Почему-то count в первом случае нормально уменьшается, а во фтором случае count в два раза больше.
---------------------------------------------------------
    level16.lesson13.bonus02
    Хорошая задача про потоки. Внизу задачи много полезных коментариев.
---------------------------------------------------------
    level16.lesson13.bonus03
    Очень хорошая задача про обрабатывание исключений с помощью UncaughtExceptionHandler
==================================================================
                    LEVEL 17
                    http://www.javenue.info/post/87
    level17.lesson02.task02
Конфликта не возникает, т.к. никто не запрещает этим самым потоком иметь одновременный доступ к одной и той
же области памяти. На самом деле каждый поток работает со своей копией переменной, т.к. у каждого потока свой
стэк вызовов методов и свои локальные переменные. Так вот, изначально, элементы массива храняться в heap jvm,
т.к. массив это объект, а объекты хранятся в heap. Когда мы создаем поток( при многоядерном процессоре)
каждый поток выполняется на отдельном ядре, и вот поток идет в heap, читает в кэш своего ядра переменную,
что-то с ней там делает, и снова в heap возвращает новое значение переменной. Т.е. поток меняет переменную
не в том месте, где она лежит в памяти, а в своем кэше. А записывает уже на то место, где она храниться в
heap.Может получиться так, несколько ядер(читай потоков) одновременно захотят свое значение записать обратно
в heap jvm, ну так этот конфликт решает уже ОС. А значение останется то, которое вернулось последним.
Советую посмотреть видео Головоча, станет более менее понятно https://www.youtube.com/user/KharkovITCourses/playlists?view=50&flow=list&shelf_id=7.
Смотреть раздел Threads все лекции, т.к. там много полезной инфы, можно не именно этот набор.
---------------------------------------------------
    level17.lesson04.task01 если же следовать условиям задачи и сделать так, то тестирование не проходит:
-----------------------------------------------------
    level17.lesson04.task03
А зачем в классе листы объявлены как funal?
И почему мы в них можем что то добавлять, ведь final переменная это неизменяемая константа?

объявляя лист ты не инициализируешь его содержимое.

то есть я могу инициализоровать его значение всего один раз?

вообще ты задал хороший вопрос =))
public final List<String> fruits = new ArrayList<String>()
это означает, что сам объект fruits ты можешь изменять, как хочешь: добавлять, вычитать, удалять и т.д. НО назначить fruits ссылку на новый объект нельзя, т.е. код
fruits = new ArrayList<String>();
вызовет ошибку.
---------------------------------------------------------------
    level17.lesson04.task04
Реализация Singleton в JAVA http://habrahabr.ru/post/27108/
How do I use a synchronized block in a static method? http://www.avajava.com/tutorials/lessons/how-do-i-use-a-synchronized-block-in-a-static-method.html
http://info.javarush.ru/JavaRush_tasks_discussion/2013/08/31/level17-lesson04-task04.html

    level17.lesson04.task05
-----------------------------------------------
    level17.lesson06.task02
До конца не понятно как работает программа
Почитать про volatile Ключевое слово volatile в Java http://ru.stackoverflow.com/questions/1271/%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-volatile-%D0%B2-java
---------------------------------------------------------------
    level17.lesson10.home02
Дебильное условие, много осталось не понятного про алгоритм приоритета пляжа.
get-теры можно не синхронизировать.
name можно не использовать.
--------------------------------------
test.level17.lesson10.home09
Что такое транзакционность???
--------------------------------------------------------------------
    level18.lesson05.task02
https://habrahabr.ru/post/178405/    Правильно освобождаем ресурсы в Java
http://book.itep.ru/10/ascii.htm    Коды символов ASCII
---------------------------------------------------------------
    level18.lesson08.task01
=============================================
http://habrahabr.ru/post/164487/        Многопоточность в Java
=====================================================
    level18.lesson10.home06
\r = CR (Carriage Return) // Used as a new line character in Mac OS before X
\n = LF (Line Feed) // Used as a new line character in Unix/Mac OS X
\r\n = CR + LF // Used as a new line character in Windows
==============================================
    test.level18.lesson10.home10
так Iterator там будет в любом случае, но по новому синтаксису — неявный!
если же ты настаиваешь на явном итераторе, то предлагаю сравнить такие два варианта кода:

for (final Iterator<Map.Entry<Integer, Integer>> i = map.entrySet().iterator(); i.hasNext(); ) {
  final Map.Entry<Integer, Integer> entry = i.next();
  System.out.println("" + entry.getKey() + "=" + entry.getValue());
}
и
for (final Map.Entry<Integer, Integer> entry : map.entrySet()) {
  System.out.println("" + entry.getKey() + "=" + entry.getValue());
}
=============================================
    level19.lesson03.task05
Изучить regex
http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#sum
https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html
------------------------------------------
    level19.lesson05.task02
\p{Blank} — A space or a tab: [ \t]
\p{Space} — A whitespace character: [ \t\n\x0B\f\r]
\s — A whitespace character: [ \t\n\x0B\f\r]

String regex = "(\\b)[0-9]+(\\s|\\b)";

По данной строке матчер ищет слова которые начинаются цифрами и заканчиваются пробелом или потому
что это просто конец слова.
--
Если пошагово читать выражение то вроде все верно, вот последняя версия

Pattern p = Pattern.compile("^([^\\s]+)\\s(\\d*\\.?\\d*?)$");
От начала строки все что не является пробелом или другим пропуском, но не менее 1 символа,
за которым следует пропуск, после которого цифра, несколько или ни одной, потом точка которой
может и не быть и за ней цифра, которых может быть несколько или не быть вообще, и завершает
все конец строки.
--
\\s здесь лишнее, оно захватывает пробел. А пробел захватывать не нужно, поскольку, если есть
несколько строк
и какая-то строка окончится числом, там пробела уже не будет и во втором файле получится склейка.
Не нужно создавать группу, просто пишем "\\b[0-9]+\\b".
Но ooevg прав — этот паттерн не учитывает буквы внутри слова. Но валидатор почему-то его принимает.
----------------------------------------------------------
    com.javarush.test.level19.lesson10.home05
Интересное решение с использованием:
String[] exnum = {"1","2","3","4","5","6","7","8","9","0"};
----------------------------------------------------------
    level19.lesson10.home10
Изучить:
1)InputStream is = Solution.class.getClassLoader().getResourceAsStream("/user/resources/avatar.gif");
2)vararg  http://allmycircuitz.blogspot.com/2014/08/varargs-java.html

 result instanceof Example
Condition 'result instanceof Object' is redundant and can be replaced with '!= null' less... (Ctrl+F1)
This inspection analyzes method control and data flow to report possible conditions that are always true or false, expressions whose value is statically proven to be constant, and situations that can lead to nullability contract violations.
Variables, method parameters and return values marked as @Nullable or @NotNull are treated as nullable (or not-null, respectively) and used during the analysis to check nullability contracts, e.g. report possible NullPointerException errors.
More complex contracts can be defined using @Contract annotation, for example:
@Contract("_, null -> null") — method returns null if its second argument is null @Contract("_, null -> null; _, !null -> !null") — method returns null if its second argument is null and not-null otherwise @Contract("true -> fail") — a typical assertFalse method which throws an exception if true is passed to it
The inspection can be configured to use custom @Nullable
@NotNull annotations (by default the ones from annotations.jar will be used)

-----------
Процент решения задач
http://info.javarush.ru/others/2014/12/13/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D0%BD%D1%82-%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87-.html
----------------------
===========================================
    level20.lesson02.task02

Разобраться с enum (valueOf) и SimpleDateFormat
+++
Правильно ли я понял что для работы с датами нужно делать так:
1. для инициализации поля private Date birthDate в методе setBirthDate используем такую конструкцию
user.setBirthDate(new SimpleDateFormat("dd MM yyyy").parse("28 09 1970"));

2. при записи этого поля в файл
user.getBirthDate().getTime()

в файле получаем строку, которая показывает сколько прошло секунд с какой то там базовой даты до 28 09 1970, это — 23320800000
3. при чтении мы преобразуем эту строку в дату
user.setBirthDate(new Date(Long.parseLong(reader.readLine())));

но если захотим эту дату вывести на консоль просто вставив в sout
System.out.println(javaRush.users.get(i).getBirthDate());

то получим
Mon Sep 28 00:00:00 IST 1970

а если так:
System.out.println(new SimpleDateFormat("dd MM yyyy").format(javaRush.users.get(i).getBirthDate()))

то, наконец то получим то что нужно
28 09 1970
----------------------------
    level20.lesson02.task03
Прочитать про Properties, Enumeration

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


Dec 2013 лекция 20
Class IllegalMonitorStateException

Если я использую локальную переменную в анонимном классе, компилятор требует объявить их final.
1. final - подсказывает программисту писателю, что это значение мы не будем менять.
2. final поле надо обязательно инициализировать.

    this - это ссылка на тот экземпляр у которого вызвали метод
Но для вызова статического класса экземпляр не нужен.
В таком случае ссылка идет по такому объекту App00.class (это тоже ссылочный тип)

    Integer от int(классы обертки от примитивов) отличаются тем что у них на одно больше
значение, т.е.любой int и  null.(Кроме double - есть NaN, Inf....)

    В нутри synchronized метода одновременно может находится только один поток. Это не
совсем так. В тот момент когда вы вызываете wait вы формально с точки синтаксиса Java остаетесь в
строчке wait, но с точки зрения многопоточности вы покидаете метод (отпустили synchronized)
и др. поток может зайти в synchronized.
    В случае sleep поток сохраняет за собой монитор
    И wait и sleep вырубают поток, но:
    1.wait - отпустили synchronized.
    2.sleep - сохраниет за собой монитор (не выходит из synchronized)


    Если метод static то synchronized выполняется по объекту класса (напр. public class App01x)
    public class App01x {
        public synchronized static void hello (int id) {
            try {
                App01x.class.wait(3000);
            }
            catch (IOException ignore) { /*NOP*/ }
        }
    }

    Если я не использую не случайно, а действительн не хочу использовать исключение
в try - catch, я вместо e пишу ignore (я действительно не буду использовать это
исключение) и в теле catch - /*NOP*/(тут пустое тело, но я так и задумал).

    Многопоточность вытесняющая.

    Астрал 1ч
    ============================================
    Dec 2013 лекция 21.1

    1. У класса всегда есть как минимум один конструктор.
    2. Если нет конструктора, компилятор добавить по умолчанию.
    3. В рамках конструктора потомка вызывается конструктор предка (super())

    super() - конструктор предка (ссылка)
    super. - ссылка на предка, который внутри вас (вызов кокструктора)
    this() - ссылка на мой конструктор (ссылка)
    this. - ссылка на меня (вызов конструктора)

    Конструкторы полностью эквивалентны методам:
    - точно также объявляются;
    - у них может быть область видимости (private, protected и т.д.);
    - они могут кидать исключения trows;
    Единственное отличие:
    - они ничего не возвращают (нельзя ставить возвращаемый результат void, int, String и т.д.)
    (нельзя декларировать возвращаемый результат)
    - нельзя ставить return чего-то (int, String, null и т.д.);
    - просто return можно;

    У Object есть метод hashcod он всегда возвращает один и тот-же int






