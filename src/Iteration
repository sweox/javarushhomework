    Core_DEC_2013_2.1
1) Итерация (циклы)
    -бинарный поиск (двоичный поиск, поиск делением пополам). Реализован в JDK.
    -System.arrayCopy метод из JDK для сверхбыстрого копирования массивов.
2)Тема вложенных циклов (границы движения внутренного счетчика зависят от внешнего цикла).
    Три самых популярных итеративных алгоритма сортировки (всех популярных пять).
    Три Итеративные (они похожи между собой):
    -пузырьком (меняются местами два рядом стоящих элемента при условии);
    -вставками
    -выборками (сравниваюися элементы, но меняются только при условии).
    Два рекурсивные:
    -быстрая сортировка;
    -сортировка слиянием.

    Операторы - это как функции, просто такое название (>, /, *). О них можно рассуждать как
о функциях.
    В Java нельзя ни добавлять новых оперторов, ни перегружать.
    Бывают опереторы:
    -унарные (операторы, которым нужен только один аргумент). Яркий пример - это отрицание "!"
(b1=!b как бы функция от булевского аргумента, возвращающая булевский элумент false).
"-" тоже унарная функция (int y = -x).
    -бинарные (которым нужно два аргумента) - <, >, !=, =, >= (возвращает boolean)
    -тернарный (в Java только один) - опертор, которому нужно три аргумента). Это как бы
укороченный if.    (i + j > 3)?"+":"-"

    Крайне не рекомендуется менять счетчик цикла внутри цикла!!!! Т.к. у того кто будет
изучать код сломается мозг.
    Программисты делятся на:
    -математики. Им все равно зачем это нужно заказчику, главное что бы было красиво.
    -физиков. Им все равно как это устроено, лижбы оно работало

    0......L - 1            for(i=0, i<L, i++)            for(i=L, i<0, i--)
    0.....L - 2                 for(j=0, j<l-i)              for(j=0, j<i)
    0....L - 3
    ...
    0...L - 0
    Для сортировки пузырьком ниспадающий массив - это ад (будет сортировать все элементы)

    Для алгоритмического собеседования надо:
    Нужно четкое пониминие человека какие бывают алгоритмы, какие структуры данных.
    Про сортировки спрашивают до мидла и синьора. Нужно знать как работают, на каких данных
лучше всего, на каких хуже.
    Двойной вложенный цикл тормозит уже при 50_000 товаров.
    Есть два разных варианта реализации хэш-таблицы:
    -с открытой адресацией;
    -с закрытой адресацией.
    В Java реализован в java.util.HashMap только один. Какой? Почему он? Какой другой?
На каких задачах одна хэш-таблица бъет другую и на какой другая бъет первую?
    Вопросы по деревьям (бинарное дерево, красно-черное дерево).
    Почитать всего Вирта.

    Arrays.binarySearch(array, element) Если элемент найден возвращает position от 0 до ...
Если элемент не найден возвращает "-(position + 1)" место где он мог бы быть.
Метод работает только на отсортированных массивах.

    Сколько раз будет искать двоичный поиск в массиве из 572_000_000
    logx(a*b) = logx(a) + logx(b)
    log2(500) + log2(1000) + log2(1000)
    2 в 9 степени 512. 2 в 10 степени 1024.
    9 + 10 + 10
    572_000_000 = 29 раз

    low = 1_500_000
    high = 1_500_000
    int midle = (low + high)/2;      3_000_000/2 =
    int лежит в диапазоне -2_000_000 ________0________ 2_000_000
                               |-------------0------------|
                          -2_000_000 -1_000_000  0          2_000_000
                               |----------|------|---------------|
    Вместо 3_000_000 будет -1_000_000 и получается:
    low = -500_000
    high = -500_000
    Поэтому есть хитрость:
    int midle = (low + high) >>> 1;
    Можно сделать вот так:
    int midle = low + (high - low) / 2;

    Есть шифты только:
    -влево  << ;
    -вправо >>, >>> ;

    Для собеседования Junior надо прочитать книгу Джошуа Блох "Эффективная Java".
Он один из соавторов JDK.
На habrahabr есть статья Джошуа Блох "Почти во всех реализациях двоичного поиска и
сортировки есть ошибка"

    System.arrayCopy(arr, int, arr, int, int) Может копировать даже в тот же самый массив (например для сдвига
вправо)

     int и float 32bit
     long и double 64bit
     У процессора три важных числа:
     -разоядность регистров;
     -шина данных;
     -шина адресов.

     На собеседовании часто спраштвают слияние отсортированных массивов!!!!

     Есть еще сортировки:
     -быстрая сортировка;(quick sort)
     -сортировка слиянием;(merge sort)

     Соотировки пузырьком, вставками, выборками работают n в квадрате
быстрая сортировка, сортировка слиянием работает быстрее n*logдвоичныйn
где n - количество элементов

    Каждый if внутри простого цикла убивает скорост в два раза.

    Два типа вопросов по Java на собеседовании:
    1. Тупые
        -почему конализационные люки круглые;
        -почему у телеги передние колеса меньше чем задние;
    2. Странные вопросы на оценку:
        -сколько бензозаправок в Лос-Анжелесе;
        -сколько тенисных шариков влезет в Боинг 737;
        -сколько весит гора Фудзи в Японии;
    3. Математические:
        -Два стеклянных шара и здание;
        -что-то с фитилями и сосудами;

    Книги:
    Соглашение о кодировании
    1.Basic level:
        -sun code convention;
    2.Middle level:
        -Макконнелл.Совершенный код;
        -Мартин.Чистый код;
        -Бек.Шаблоны реализаций корп...ий.RU.djvu
        -Фаулер.Рефакторинг.RU

    Самый качественный код у OpenSource библиотек (например Hibernate(100_000 строк кода, Spring)

    Вопросы на собеседовании:
    1.Алгоритмы поиска (желетелльно называть 3-5 штук).
    2. Хэш-структуры Hash-Map.
    3. Деревья, b-деревья(учить не будем, но они очень похожи на Красно-Черные деревья (именно они Кр-Черн
используются в классе TreeMap и у них есть ряд потрясающих свойств(когда вставляешь элементы в дерево оно может
портится и Кр-Черн дерево умеет бороться с этой своей порчей)))
    Красно-Черные деревья входят в стандартные библиотеки всех языков программирования
    Все базы данных содержат в качестве индексов B-деревья
    4. Программистский фальклор, это спрашивают и на этом останавливаются
    -Алгоритм инвертирования массива
    -Слияние отсортированных массивов;
    -бинарный поиск (как будет работать на не отсортированном массиве и др);
Примерно раскажите как он работает(на отсортированном массиве делим пополам; оценить примерное колличество
делений; какой выигрыш усли я использую бинарный поиск а не линейное сканирование; а если 4, а если 100,
а если 1_000_000 есть смысл бинарный поиск использовать)
    Для того чтобы 1000 превратить в 1 нужно 10 делений ( 2 в степени 10 равно 1024)
    Десять делений уменьшают диапазон поиска в 1000 раз.
    2 в степени 20 равно 1_000_000
    2 в степени 30 равно 1_000_000_000